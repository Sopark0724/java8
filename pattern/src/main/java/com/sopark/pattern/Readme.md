# 자바의 Adapter, Decorator, Façade, Proxy 패턴의 유사점과 차이점

## 비슷한점
- 4개의 패턴은 클래스를 인터페이스로 랩핑하여 사용하는 패턴.

## 패턴 정의 요약

- Adapter : **한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환합니다.**
어댑터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸수 없는 클래들을 연결해서 쓸수 있습니다.

- Decorator : **객체에 추가적인 요건을 동적으로 첨가한다.** 데코레이터는 서브클래스를 만드는것을 통해서
기능을 유연하게 확장할 수 있는 방법을 제공한다.

- Facade : 어떤 서브시스템의 일련의 인터페이스에 대한 **통합된 인터페이스**를 제공합니다. 
    퍼사드에서 고수준 인터페이스를 정의하기 때문에 서브시스템을 더 쉽게 사용할 수 있습니다. 

- Proxy : 어떤 객체에 대한 접근을 제어하기 위한 용도로 **대리인이나 대변인에 해당하는 객체를 제공하는 패턴.** 
프록시는 어떠한 것(이를테면 네트워크 연결, 메모리 안의 커다란 객체, 파일, 또 복제할 수 없거나 수요가 많은 리소스)과도 
인터페이스의 역할을 수행할 수 있다.

## 패턴 차이점

### 가장큰 차이점은 사용하는 목적이다.

- Adapter : 기존 코드는 그대로 유지하며 변경된 2개의 인터페이스를 연결해 주는 역활.

- Decorator : 기존 기능에 추가적으로 기능 추가하기에 적합하며, Chain 을 권장함.

- Facade : 여러 기능들을 하나의 추상화 레벨로 맞춰서 사용하도록 함.

- Proxy vs Decorator vs Adapter : 인터페이스 구현체와 인터페이스를 구성으로 가지고 있기 때문에 데코레이터나 어댑터 패턴과 비슷하게 보일수도 있지만
                                  Adapter 패턴은 서로 다른 인터페이스를 연결해 주는 역활을 담당하고 데코레이터패턴은 행동을 동적으로 추가하며
                                  체이닝을 권장하지만 프록시패턴은 권장사항은 아니다.

| 패턴  | 목적|
|---|---|
| adapter  | 인터페이스의 전환 |
| decorator | 동적으로 기능 추가 |
| Facade | 복잡한 기능을 하나의 추상 메소드로 처리 |
| Proxy  | 객체의 대리인 역활을 하며 한번 랩핑한 클래스 |


