# 도메인 주도 설계 (Domain Driven Design)

**도메인 모델**은 단지 도메인 전문가의 머릿속에만 존재하는 지식이 아니라 해당 지식을 엄격하게 구성하고 선택적으로 **추상화**한 것.
=> 지하철 노선도는 지도를 형상화 하여 표현하고 있지 않지만 사용자들이 이해하기 쉽게 되어 있는 부분이 도메인 모델과 비슷한 부분이라 할 수 있음.

소프트웨어의 본질은 해당 소프트웨어의 사용자를 위해 도메인에 관련된 문제를 해결하는 능력(소프트웨어의 본진은 요구사항에 맞게 구현하는것.)

모델은 결코 완벽해질 수 없으며, 다만 계속 발전해나갈 뿐이다. 모델은 도메인을 이해하는 데 실용적이고 유용해야 한다. 또한 모델은 쉽게 구현하고 이해하기에 충분할 만큼 엄밀해야한다.

ㅇ Service Layer 에 로직이 있을 경우
1. 업무전문가가 해당 코드를 일고 규칙을 검증하지 못한다.
2. 해당 업무에 종사하지 않고 기술적인 측면만 담당하는 사람은 코드와 요구사항을 결부 시키키가 어렵다.

> 개발 사항에 대해서 알기 위해서는 API 를 통해서 일일히 따라가며 기능 확인을 해보아야 한다. 하지만 그런 기능들이 entity 에 녹여져 있다면 따로 확인할 필요성이 줄어든다.

작업 순서
1. 유비쿼터스 언어로 이야기 하기
개발자, 기획자, 사업팀 간의 언어의 통합이 이뤄져야한다.
=> 테이블, 행 같은 언어를 통해 사용자에게 오해의 소지를 없애야 한다.

코드와 그것의 기반이 되는 모델이 긴밀하게 연결되면 코드에 의미가 부여되고 모델과 코드가 서로 대응하게 된다.
 
# TDD (Test Driven Development : 테스트 주도 개발)

고전적인 개발방식
- 소프트웨어 개발을 하기 위해서는 문제영역을 시작점으로 그 문제를 풀기 위해 사용하는 방법으로 콘솔 출력, 간단한 테스트, 에러 발생 다시 기능구현 콘솔, 간단한 테스트
- 현업에서 지라 comment TC 작성, google sheet 를 시용한 TC 작성, 그냥 개발자 테스트

> 컨디션이 좋지 않아 평소보다 마음에 들지 않는 코드지만 '문제가 있으면, 나중에 테스트할 때 나오겠지' 라는 식으로, 소스에도 마음에도 덮개를 씌워놓고 개발 끝을 외치며 퇴근을 한다. 세상에 변하지 않는 것이 어디 있을까? 시간이 지나고, 코드의 크기가 커지면 커질수록, 버그 수정에 필요한 부분을 찾아내기 어려워진다. 그러다가 디버깅용 코드와 비지니스 로직 코드가 3:7 정도 비율로 된다. 

고전적인 개발 방식의 문제점들
1. 특정 모듈의 개발 기간이 길어질수록 개발자의 목표의식이 흐려진다.
 - 어디까지 짰더라?
 - 아, 내가 지금 뭘 하는 거였지?
 - 이 모듈이 무슨기능을 해야 한댔더라?
 
2. 작업 분량이 늘어날수록 확인이 어려워진다.
 - 로그가 어디 있더라?
 - 이것도 화면으로 출력해보고...
 
3. 개발자의 집중력이 필요해진다.
 - 앗! 화면 지나갔다. (로그화면)
 
4. 논리적인 오류를 찾기가 어렵다.
 - 여기서 그러니까 이 값이 들어가면 나와야 하는 게... 아... 이게 맞던가?

5. 코드의 사용 방법과 변경 이력을 개발자의 기억력에 의존하게 되는 경우가 많다.
 - 맞아! 개인고객 인증을 고치면 법인 고객인증 부분도 함께 고쳤어야 했었지!!
 
6. 테스트 케이스가 적혀 있는 엑셀파일을 보며 매번 테스트를 실행하는게 점점 귀찮아 져서는 점점 간소화하는 항목들이 늘어난다.
 - 날짜? 1111. 주민전호? 우선 222222-22222222 주소? 서울 개똥이네.
 
7. 코드 수정 시에 기존 코드의 정상 동작에 대한 보장이 어렵다.
 - 휴! 찾았다. 여길 고쳐야 하는 거였군. 아, 근데 이 금칙어 필터 모듈 혹시 다른 데서도 쓰는거 아냐?
 
8. 테스트를 해볼면 소스코드에 변경을 가하는 등, 번거로운 선행 작업이 필요할 수 있다.
 - 입고 처리를 테스트하려면, 주문이 완료됐다고 테이블에 직접 업데이트를 해줘야...
 
9. 그래서 소스 변경 시 해야 하는 회귀 테스트는 곧잘 희귀테스드가 되기 쉽다.
 - 아, 그걸 언제 다 다시 테스트해? 우선 급한 불부터 끄고 보자구. 집에 안갈꺼야?
 
10. 이래저래 테스트는 개발자의 귀중한 노동력을 적지 않게 소모한다.
 - 품질 담당자 가라사대 : 소스 수정사항 생기면 엑셀에 적힌 단위 테스트 다시 수행하는 걸 절대! 빼먹지 마!
 
이런 문제는 어제 오늘 일이 아니고, 이미 수십 년 전부터 소프트웨어 개발 영역에서 끊임없이 문제로 제기돼왔다. 해당 문제를 제거하기 위해, 떄로는 사회 공학적이고, 때로는 시스템적인 다양한 방법을 찾아왔다. **하지만 여전히 은탄환은 없다.**

## 테스트 주도 개발

> TDD란 프로그램을 작성하기 전에 테스트를 먼저 작성하는 것 - 켄트백 -

문서로 만드러 머리로 생각하고 눈으로 확인할 것인가? 아니면 예상 결과를 코드로 표현해놓고 해당 코드가 자동으로 판단하게 할 것인가?

애자일 방법론의 실천 방법으로 **TDD**, 짝프로그래밍, 일일빌드, 지속적인 통합등 다양한 실천 방법들이 있다.

![TDD process](https://s3.amazonaws.com/ckl-website-static/wp-content/uploads/2017/03/TDD-e1492712699769-300x300.png)

TDD를 이용한 개발은 크게 '질문 -> 응답 -> 정제' 라는 세 단계가 반복적으로 이루어진다.

일반적인 소프트웨어의 개발이 기능을 구현한다고 테스트를 수행하는 형태라고 한다면, TDD에서는 그와 반대로 진행된다.

'작성하고자 하는 메소드나 기능이 무엇인지 선별하고 작성 완료 조건을 정해서 실패하는 테스트 케이스를 작성하는 것' 이다.
=> 스켈레톤 구현

> 최대한 빨리 실패하기. OK 조건을 사전에 정해두고 빠르게 실패를 경험하며, 그 조건을 등대로 삼아 실패 상황을 최대한 빨리 극복하고자 노력하는 경향이 있다.

한 사이클이 끝나기 전에 리팩토링 작업 통해 간결한 코드 만들기 수행. TDD 와 소스를 개선하는 리팩토링은 궁합이 잘 맞는다. 이유는 리팩토링은 작업전과 작업후의 결과물은 항상 같아야 하기 때문이다. 그것을 쉽게 검증할 수 있는 방법은 테스트코드가 된다.

리팩토링 시간에는 다음과 같은 고민을 해본다.

- 소스의 가독성은 적절한가?
- 중복된 코드는 없는가?
- 이름이 잘못 부여된 메소드나 변수명은 없는가?
- 구조의 개선이 필요한 부분은 없는가?

> 이미 성공한 케이스가 있기 때문에 해당 부분들에 대해서 고민 후 소스 수정한다. 문제가 있으면 테스트 코드를 실패를 하게 되고 다시 수정을 하면된다.









 
 
 
 
 
 
 
 
 





